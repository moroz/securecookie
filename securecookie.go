package securecookie

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"fmt"

	"golang.org/x/crypto/chacha20poly1305"
)

const (
	KeySize   = chacha20poly1305.KeySize
	NonceSize = chacha20poly1305.NonceSizeX
	Overhead  = chacha20poly1305.Overhead
)

var ErrKeySize = errors.New("Invalid key size")
var ErrMsgTooShort = errors.New("Message too short")

type Store interface {
	// Encrypt encrypts and authenticates the given plaintext and produces a binary
	// message that contains all the information necessary to verify it.
	Encrypt(plaintext []byte) (msg []byte, err error)

	// Decrypt decrypts and verifies a binary message and returns the original
	// binary plaintext.
	Decrypt(msg []byte) (plaintext []byte, err error)

	// EncryptCookie encrypts the given plaintext and produces a string that can be
	// safely stored in an HTTP cookie.
	EncryptCookie(plaintext []byte) (cookie string, err error)

	// DecryptCookie decodes a cookie generated by `EncryptCookie` and returns
	// the original binary plaintext.
	DecryptCookie(cookie string) (plaintext []byte, err error)
}

type store struct {
	key []byte
}

func NewStore(key []byte) (Store, error) {
	if len(key) != KeySize {
		return nil, fmt.Errorf("%w %d (want %d)", ErrKeySize, len(key), KeySize)
	}

	return &store{key: key}, nil
}

// Encrypt encrypts and authenticates the binary plaintext with the secret key.
func (s *store) Encrypt(plaintext []byte) ([]byte, error) {
	// Allocate buffer with the initial size just big enough to generate a random nonce,
	// but with capacity for the whole message (nonce + ciphertext + authentication tag)
	nonce := make([]byte, NonceSize, NonceSize+len(plaintext)+Overhead)

	// Generate a random nonce. `rand.Read` will only generate as much data as can fit
	// within the initial size of the slice
	if _, err := rand.Read(nonce); err != nil {
		return nil, err
	}

	// Initialize an XChaCha20-Poly1305 AEAD with the secret key
	aead, err := chacha20poly1305.NewX(s.key)
	if err != nil {
		return nil, err
	}

	// Encrypt and authenticate the message
	msg := aead.Seal(nonce, nonce, plaintext, nil)

	// The return value is nonce + ciphertext + authentication tag in one byte slice
	return msg, nil
}

// Decrypt decrypts and verifies the provided message in the format: nonce+ciphertext+authentication tag.
// Returns verified plaintext and error, if any.
func (s *store) Decrypt(message []byte) ([]byte, error) {
	if len(message) < NonceSize+Overhead {
		return nil, fmt.Errorf("%w (got %v, want %v or more)",
			ErrMsgTooShort, len(message), NonceSize+Overhead)
	}

	nonce, ciphertext := message[:NonceSize], message[NonceSize:]
	aead, err := chacha20poly1305.NewX(s.key)
	if err != nil {
		return nil, fmt.Errorf("Decrypt: %w", err)
	}

	return aead.Open(nil, nonce, ciphertext, nil)
}

// EncryptCookie encrypts plaintext and produces a cookie
func (s *store) EncryptCookie(plaintext []byte) (string, error) {
	msg, err := s.Encrypt(plaintext)
	if err != nil {
		return "", err
	}

	return base64.RawURLEncoding.EncodeToString(msg), nil
}

// DecryptCookie decrypts and verifies cookie and returns plaintext
func (s *store) DecryptCookie(cookie string) ([]byte, error) {
	msg, err := base64.RawURLEncoding.DecodeString(cookie)
	if err != nil {
		return nil, fmt.Errorf("DecryptCookie: %w", err)
	}

	return s.Decrypt(msg)
}
